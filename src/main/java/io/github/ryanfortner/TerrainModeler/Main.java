package io.github.ryanfortner.TerrainModeler;

import org.jzy3d.chart.Chart;
import org.jzy3d.chart.controllers.mouse.camera.AWTCameraMouseController;
import org.jzy3d.chart.factories.AWTChartFactory;
import org.jzy3d.colors.ColorMapper;
import org.jzy3d.colors.colormaps.ColorMapRainbow;
import org.jzy3d.maths.BoundingBox3d;
import org.jzy3d.maths.Coord3d;
import org.jzy3d.maths.Range;
import org.jzy3d.plot3d.builder.Mapper;
import org.jzy3d.plot3d.builder.concrete.OrthonormalGrid;
import org.jzy3d.plot3d.primitives.Shape;
import org.jzy3d.plot3d.builder.SurfaceBuilder;
import org.jzy3d.plot3d.rendering.canvas.Quality;

import javax.swing.*;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.awt.*;
import java.io.*;

public class Main {

  /* Global variables and constants */
  private JFrame frame;
  private JPanel chartPanel;
  private Chart chart;
  private JButton fileButton;
  private final int resolution = 1201;
  private final int steps = 200; // how "pixelated" we want the final image to be

  /**
   * Reads *.hgt file into a 2D array of signed shorts.
   *
   * @param pathname path to file on disk.
   * @param resolution number of grid points.
   *                   Each tile covers exactly 1deg lat x 1deg long.
   *                   If 3 arcsec between tiles, like SRTM dataset,
   *                   1 deg = 3600 arcsec.
   *                   3600 arcsec / 3 arcsec = 1200 resolution.
   *                   +1 since both edges are included.
   *                   1201
   * @return 2D array of signed shorts with elevation data
   * @throws IOException if file is not found or resolution mismatch is detected
   */
  private static short[][] readHGT(String pathname, int resolution) throws IOException {
    /* Create a file to work with using the provided path name */
    File hgt = new File(pathname);

    /* Verify that the file exists */
    if (!hgt.exists()) {
      throw new IOException("File does not exist.");
    }

    /*
     * Validate the resolution of the file
     * 3 arc-second files are 1201 col x 1201 rows.
     * Considering both high & low bytes,
     * the total file size is 2 * resolution^2
     */
    if (hgt.length() != 2 * Math.pow(resolution, 2)) {
      throw new IOException("Resolution mismatch.");
    }

    /* Create elevation array to work with, resolution^2 pixels */
    short[][] elevationData = new short[resolution][resolution];

    try (FileInputStream inputStream = new FileInputStream(hgt)) {
      for (int i = 0; i < resolution; i++) { // Iterate through rows
        for (int j = 0; j < resolution; j++) { // Iterate through columns

          /* Handle endianness */

          /* Shift the high byte to its correct position (upper 8 bits of the 16-bit number) */
          int highByte = inputStream.read();
          highByte = highByte << 8;

          /* Get the last 8 bits (the low byte) */
          int lowByte = inputStream.read();
          lowByte = lowByte & 0xFF;

          /* Combine the two bytes and typecast to short */
          elevationData[i][j] = (short) (highByte | lowByte);
        }
      }
    } catch (IOException e) {
      e.printStackTrace();
    }

    return elevationData;
  }

  /**
   * Method to handle the uploading (or re-uploading) of a *.hgt file.
   * Asks the user for a file, then refreshes the GUI.
   */
  private void handleFileUpload() {
    /* Have the user select a file, limited to just .hgt format */
    JFileChooser fileChooser = new JFileChooser();
    fileChooser.setFileFilter(
      new FileNameExtensionFilter("HGT Elevation Data", "hgt")
    );

    if (fileChooser.showOpenDialog(frame) == JFileChooser.APPROVE_OPTION) { // Proceed if file is accepted
      File selectedFile = fileChooser.getSelectedFile();
      fileButton.setText(selectedFile.getName()); // Set button in GUI to be labeled by the file name

      try {
        /* Convert the terrain to an array, update the GUI */
        short[][] terrain = readHGT(selectedFile.getAbsolutePath(), resolution);
        updateChart(terrain);
      } catch (IOException e) {
        JOptionPane.showMessageDialog(frame, "Error reading file: " + e.getMessage());
      }
    }
  }

  /**
   * Updates the terrain model portion of the GUI.
   * Redraws everything through Jzy3d libraries.
   * Heaviest method in the program.
   *
   * @param terrain array of signed shorts, as generated by `readHGT(x,y)`
   */
  private void updateChart(short[][] terrain) {
    /* Clear previous chart from the panel */
    chartPanel.removeAll();

    /* Create the mesh grid */
    OrthonormalGrid grid = new OrthonormalGrid(
      new Range(0, resolution - 1), steps, // x-axis
      new Range(0, resolution - 1), steps  // y-axis
    );

    /* Create the mapper */
    Mapper mapper = new Mapper() {
      @Override
      public double f(double x, double y) {
        int ix = (int) x;
        int iy = (int) y;

        return terrain[ix][iy];
      }
    };

    /* Create the surface using the grid and mapper */
    Shape surface = new SurfaceBuilder().orthonormal(
      grid,
      mapper
    );

    /* Color the surface by elevation ("heatmap")*/
    surface.setColorMapper(new ColorMapper(
      new ColorMapRainbow(),
      surface,
      new org.jzy3d.colors.Color(1, 1, 1, 1.0f)
    ));

    /* Make the surface visible */
    surface.setFaceDisplayed(true);
    surface.setWireframeDisplayed(false);

    /* Create the chart and add surface to it */
    chart = AWTChartFactory.chart(Quality.Fastest());
    chart.getScene().getGraph().add(surface);

    /* Manually set z bounds to "zoom us out", this makes elevation less exaggerated */
    chart.getView().setBoundsManual(new BoundingBox3d(
      surface.getBounds().getXmin(), surface.getBounds().getXmax(),
      surface.getBounds().getYmin(), surface.getBounds().getYmax(),
      -10000, 10000
    ));

    /* Allow for panning/zooming using mouse & scroll wheel */
    AWTCameraMouseController mouse = new AWTCameraMouseController(chart);
    chart.addController(mouse);

    /* Add the Chart to the main window, centered */
    Component canvas = (Component) chart.getCanvas();
    chartPanel.add(canvas, BorderLayout.CENTER);

    /* Refresh the GUI */
    chartPanel.revalidate();
    chartPanel.repaint();
  }

  /**
   * Core GUI initialization method. Configures all frames, toolbar, buttons
   */
  public void initGui() {

    /* Use the operating system's native look and feel, makes it not look like the 1900s */
    try {
      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Exception e) {
      e.printStackTrace();
    }

    /* Create and configure frame */
    frame = new JFrame("Terrain Modeler");
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setSize(1200, 800);
    frame.setLayout(new BorderLayout());

    /* Create toolbar */
    JToolBar toolBar = new JToolBar();
    toolBar.setFloatable(false);

    /* Create and configure buttons */
    fileButton = new JButton("Upload Data");
    JButton screenshotButton = new JButton("Take Screenshot");
    JButton resetButton = new JButton("Reset View");
    JButton topButton = new JButton("Top View");
    JButton sideButton = new JButton("Side View");
    JButton exitButton = new JButton("Exit");

    /* Add all buttons to toolbar */
    toolBar.add(fileButton);
    toolBar.addSeparator();
    toolBar.add(screenshotButton);
    toolBar.add(resetButton);
    toolBar.add(topButton);
    toolBar.add(sideButton);
    toolBar.add(Box.createHorizontalGlue());
    toolBar.add(exitButton);

    frame.add(toolBar, BorderLayout.NORTH);

    /* Create chart container */
    chartPanel = new JPanel(new BorderLayout());
    chartPanel.setBackground(Color.DARK_GRAY);
    frame.add(chartPanel, BorderLayout.CENTER);

    /* ActionListeners for buttons, these wait for events, then take action (duh) */
    fileButton.addActionListener(
      e -> handleFileUpload()
    );

    screenshotButton.addActionListener(
      e -> {
        if (chart != null) {

          /* Ask user for the name & location they want their screenshot to be at */
          JFileChooser saver = new JFileChooser();
          FileNameExtensionFilter filter = new FileNameExtensionFilter("PNG Image (*.png)", "png");
          saver.setFileFilter(filter);
          saver.setDialogTitle("Save Terrain Screenshot");

          if (saver.showSaveDialog(frame) == JFileChooser.APPROVE_OPTION) {

            /* Ensure path ends in .png */
            File f = saver.getSelectedFile();
            String path = f.getAbsolutePath();
            if (!path.toLowerCase().endsWith(".png")) {
              f = new File(path + ".png");
            }

            try {
              chart.screenshot(f);
            } catch (IOException ex) {
              ex.printStackTrace();
            }
          }
        }
      }
    );

    resetButton.addActionListener(
      e -> {
        if (chart != null) {
          chart.setViewPoint(new Coord3d(Math.PI / 4, Math.PI / 4, 0)); // TODO: fix this?
          chart.getView().shoot();
        }
      }
    );

    topButton.addActionListener(
      e -> {
        if (chart != null) {
          chart.setViewPoint(new Coord3d(0, Math.PI / 2, 0));
          chart.getView().shoot();
        }
      }
    );

    sideButton.addActionListener(
      e -> {
        if (chart != null) {
          chart.setViewPoint(new Coord3d(Math.PI / 2, 0, 0));
          chart.getView().shoot();
        }
      }
    );

    exitButton.addActionListener(
      e -> System.exit(0)
    );

    frame.setVisible(true);
  }

  public static void main(String[] args) {
    /* NEEDS to be run in a Thread. Swing doesn't like it otherwise (action listeners?) */
    SwingUtilities.invokeLater(() -> new Main().initGui());
  }
}